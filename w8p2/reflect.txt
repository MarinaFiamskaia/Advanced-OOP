/*
Student:	Marina Fiamskaia
Student ID:	025-698-051
email:		mfiamska@myseneca.ca
Date:		July 26, 2022
Subject:	OOP345 NAA
Project:	Workshop 8 part 2 reflect

****I have done all the coding by myself and only copied the code that my professor provided to complete my workshops and assignments.****
*/
In the workshop eight I have learned how to create a program component of quadratic complexity and how to use smart pointer to move an object. In this workshop we have combined two lists and used a smart pointer to ensure that memory is deallocated in the possible presence of an exception. Furthermore, in this workshop we have learned what is Luhn Algorithm its use and implementation.
The smart pointers are defined in the header <memory>. Smart pointers manage the memory of the object that is pointing to. The main advantage of smart pointers is that they ensure that the actual object is deallocated, and no memory leak is possible when it goes out of scope. When using raw pointers, we need to deallocate for every possible exit point including exceptions. It is no easy task to handle deallocation of raw pointer during exception handling. We will need quite complex logic for try{}catch{} block to handle the deallocation of pointer created within the try{} block that had thrown an exception and needs to be deallocated in the catch{} segment of the code. The smart pointer handles the deallocation of the memory the object is pointing to when it goes out of scope. For example in writeSmart(), we create a unique_ptr<EmployeeWage> empWage(new EmployeeWage(emp[i].name, sal[j].salary)); And then we send the object for salary range validation and Luhn’s check. In both check if the object does not pass validation, it will throw an exception. That is, it will exist the code block. The smart pointer will make sure that empWage pointer id deallocated before exiting the code block and throwing exception. Therefore, no memory leaks will occur.
In my code in order to create a dynamic raw pointer to the new object EmployeeWage and not to have a memory leak when throwing exceptions first I have created local new object EmployeeWage and then a pointer to it. I was not able to create a purely dynamic raw pointer with resources on the outside using “new” operator and so that it would not be causing memory leaks after failed validation checks. Whereas the use of smart pointer allowed me to use purely dynamic pointer with resources on the outside that would not cause memory leaks after failed validation checks. The syntax for creating a smart pointer is fairly similar to the raw dynamic pointer std::unique_ptr<EmployeeWage> empWage(new EmployeeWage(emp[i].name, sal[j].salary)); It uses the “new” operator just like raw pointer. The major difference is the std::unique_ptr<EmployeeWage> empWage…. Where as the syntax for dynamic raw pointer it would be EmployeeWage * empWage=new EmployeeWage (emp[i].name, sal[j].salary).
And lastly in this workshop I have learned Luhn Algorithm. The idea of the algorithm is to validate the given sequence of numbers against the check number to make sure the sequence is legal. The validation number is the last in the given sequence. The rest of the sequence is multiplied and summed based on given algorithm. For the even length of the sequence each number in the sequence is multiplied by *1 *2 *1 *2 and so on. For odd length of the sequence each number is multiplied by *2 *1 *2 *1 and so on. Then the result of multiplication is summed. Where the result is more than 9, the integers need to be summed first. For example if result of multiplication is 7*2=14, the integers need to be summed first 1+4=5. Then the final result is calculated 10-(fResult mod 10) and validated against given check digit. The code for algorithm I have taken from https://www.geeksforgeeks.org/luhn-algorithm/
I am looking forward to work with smart pointers in the future. It seems like an easy solution for dynamic memory issues.
