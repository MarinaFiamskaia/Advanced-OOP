/*
Student:	Marina Fiamskaia
Student ID:	025-698-051
email:		mfiamska@myseneca.ca
Date:		June 6, 2022
Subject:	OOP345 NBB
Project:	Workshop 3 part 2 reflect

****I have done all the coding by myself and only copied the code that my professor provided to complete my workshops and assignments.****
*/

In the third workshop I have learned to design and implement several class templates and test them on different instantiations. The main topics that were covered are designing and coding a class template; designing a class variable within templated class and specializing it for particular type; instantiating a template class; specializing a member function of a templated class to process a particular type; and deriving a templated class from another templated class.
In this workshop we did not split “Collection” and “Set” modules into header and c++ files. It was done so because these two modules are template declarations. The template is a guideline or a blueprint that compiler uses to initiate and generate actual objects from. Template is a declaration of an object and does not contain an initialization. In order to instantiate a templated object the compiler needs to be able to access the implementation model of the methods. By placing the complete implementation model in the header file, we are making it visible so that compiler can instantiate the object using declared template.
It is necessary to mention that templated class Collection contain a class variable T c_dummy. In order to instantiate this class member, I have used the outside the class scope instantiation method for static class members. It is done in this manner because class variables are not really a part of an object instance, and rather exists independently of the object instances. And therefore, needs to be stored independently of its instances. It also can be instantiated using “inline” keyword to let the compiler know that we want to inline this line of code.
Also, we need to specialize T c_dummy class variable for Collection<Pair, 100> in order to achieve the desired output. If we do not specialize T c_dummy for the Collection<Pair, 100> it would follow the general suit and instantiate using empty no argument constructor. That is both strings contained in object Pair c_dummy would be initialized to default values but we rather need a specific strings to be recorded in the Pair c_dummy object.
Additionally, in the part 2 of the workshop in the “Collection” module we modified the add member function by adding “virtual” keyword and have added virtual empty destructor. The rules of inheritance state that derived class inherits fully the parent object. Yet the inherited add function does not exactly suit our needs in the templated derived class Set. We have additional step that the function needs to perform before following its logic outlined in the base class. Because of One definition rule we use keyword “virtual” in the base class function. It tells the compiler that there is another version of the function exists. Compiler will determine at the run-time which function to invoke based on the object type. For the same reasons we have created virtual empty destructor in the “Collection” module. It ensures that appropriate destructors will be called when we have dynamic types within derived or base classes. 
Another topic that was covered by this workshop is std:fabs objects defined in the cmath library. This function allows us to compute the absolute value of the floats, doubles and long doubles. I believe it could be quite useful for many occasions and it is good to know and to be able to use it when necessary.
For this workshop, in the “Set” module we need to specialize our add function for the Set<double> case. It is done so because under all other circumstances before item is added to the set object it needs to be verified that it does not already exist within the object. Doing such verification with floating point types becomes challenging since the floating point types are stored in the memory to the approximate value and not exact like with ints or chars. So that a double with value of 1.222 in memory could be stored as 1.2219999999 therefore such evaluations might not be exactly. It is more accurate to implement different logic for evaluating a floating points. Specifically, this workshop implements the model of evaluating the absolute value of difference between stored items and incoming item using std::fabs function.
For this workshop, in the “Pair” module it was necessary to add 4 functions. First one, the no argument default constructor. It was need for the templated class Collection when the type is Pair. In order for the Pair c_objects[] member of the class Collection be instantiated to the empty array, compiler required the no argument constructor. Another Pair public member function I have added display function that receives and returns ostream object. It also was needed for the templated class Collection when the type is Pair. Compiler needed to know how to display and what to display when Collection<Pair, 100> was required to produce the output. Same goes for the Pair helper function operator<< overload. Compiler needed instructions how to process operator<< for the Collection<Pair, 100>. And lastly, I have added operator== overload for this class. It was also necessary for the compiler to know how to proceed in case of Collection<Pair, 100> when performing the add member function. All 4 of these functions were needed to ensure for the template to work equally well with class Pair as with build-in types.
Overall, I did find this workshop more challenging than the previous two due to implementation of many new complex ideas and their syntax. But I was able to overcome it by continuously referring to the course notes, professor’s power points, lectures, supplemental videos and code samples. Also, I did use the https://en.cppreference.com/ website for more detailed information and additional syntax samples. 
