/*
Student:	Marina Fiamskaia
Student ID:	025-698-051
email:		mfiamska@myseneca.ca
Date:		June 21, 2022
Subject:	OOP345 NAA
Project:	Workshop 5 part 2 reflect

****I have done all the coding by myself and only copied the code that my professor provided to complete my workshops and assignments.****
*/
 
In the workshop five I have learned how to design and code a templated class that allocates and deallocates dynamic memory; design and code a function object; design and code a lambda expression; code a member function that receives the address of a callback function to execute; throw exceptions of different types; distinguish exception types from one another; and how to handle exceptions.
In the earlier workshops when we designed and coded the templated classes it didn’t manage the resources outside the class. In this workshop the templated class has a dynamically allocated array of objects that is templated class has a composition relationship with objects it manages. It controls the lifetime of dynamic array of objects. Therefore, templated class Collection has to follow the rule of five. It is responsible for copying and destroying the resources. Furthermore, during adding operation it is responsible for the management of resources such as allocation, copying and deallocation. Designing and coding such templated class is not much different than non-templated class.
Another new concept learned in this workshop is how to design and code a function object – functor. Functor is an object that represents a function. Essentially it is nothing more than regular object that has operator() overload as one of its public  members. 
Next topic new concept learned is Lambda expressions. Lambda expression is a method of creating localized function. It can capture variables from its surrounding scope and it can be anonymous. 
Both types functors and lambda expression represents the nested function type that can be overloaded, can access variables within the scope of their host function, and are known as closures. Lambda expressions are used for simple logic that is only required locally. Most often lambda expressions are used only once within the local scope or if used multiple times within the local scope is not used anywhere else outside the module. Whereas functors are used for more complex logic that needs to maintain specific states. It is designed to be used outside it’s module.
There is also a function pointer type that represent a pointer to the function. It is used for more complex logic that doesn’t need to maintain a specific state and does not depend on anything but function parameters. We have designed and coded the function pointer in this workshop as well. It is located in templated class Collection as one of the private members. It is the pointer to an observer function: when an item has been added to the collection, the class Collection will call this function informing the client about the addition. The function pointer is set to the address of the executable function using void setObserver(void (*observer)(const Collection<T>&, const T&)){} method.
Also, in this workshop I have learned how to throw exceptions of different types. The one argument constructor for SpellChecker generates an exception if it fails to open a specified file. If the file is failed to open, the constructor reports an error by throwing an exception of type char*. This error is handled in the w5_p2.cpp try{}catch(const char*){}block. To achieve the same result but without the exceptions on the constructor side I would use similar logic for printing error message: if(file failed to open)std::cout << “ERROR: file failed to open”;else{constructor logic}; Or another option is to expect the client to open the file, and then pass it to constructor for reading. This method would require the client to handle possible errors while attempting to open the file, as well as closing it once the constructor is done reading. The client would use similar logic again if(file failed to open)std::cout << “ERROR: file failed to open”;else{create new object by calling one argument constructor). Both methods constructor and client side allow to handle possible errors without throwing exceptions.
The two modules Movie and Book contain almost identical logic in loading data from the file. In order to reduce the redundancy two methods could be implemented. One method is to create a utility function for reading, extracting and loading from file logic. I would place it in separate Utility module. Or another method is to create a template function for the same logic in the separate module. Creating templated function probably would be more sensible as it allows for greater flexibility in its implementation.
Both modules are instantiated from the main() function and using custom constructor, but they also contain a default constructor. On line 56 of the main module the Collection object that contains empty dynamic array of  Book objects is instantiated using Collection one argument constructor that in turn calls the default book constructor. Similarly, on line 161 an array of empty Movie objects is created using Movie default constructor. Therefore, both modules end up using the empty default constructor. Compiler expects the non-argument constructor to be defined in order for it to be used. 
Another topic expanded in this workshop is different exception types such as std::out_of_range. It defines a type of object to be thrown as exception. It reports the error that occurred when attempt to access the element outside of defined range was made.


