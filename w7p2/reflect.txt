/*
Student:	Marina Fiamskaia
Student ID:	025-698-051
email:		mfiamska@myseneca.ca
Date:		July 18, 2022
Subject:	OOP345 NAA
Project:	Workshop 7 part 2 reflect

****I have done all the coding by myself and only copied the code that my professor provided to complete my workshops and assignments. ****
*/
In the workshop number seven I have learned how to copy data from a file into sequential container; to use numeric library to accumulate data values; to use a lambda expression to specify an operation on each value in a data set; and to use the algorithm library to sort data values. The main goal of this workshop was to learn to use algorithms category of the Standard Template Library, as well as to expand our experience with containers, lambda expressions, and reading and copying data a from file.
In this workshop I have used numerous STL functions such as:
std::all_of() for the display functionality. If it prints all instances of Covid objects in a m_covid vector, it will return boolean true. If std::all_of returns true the display functionality will calculate totalCases and totalDeaths. I have chosen to use std::all_of() because I wanted to implement any other function besides std::for_each() for the purpose of practice and I wanted to include another lvl of validation making sure it read and printed all instances of Covid before it will calculate the totalCases and totalDeaths. The std::for_each() will be suitable choice for the functionality as well. It would look like: std::for_each(m_covid.begin(), m_covid.end(), [&out](const Covid& theCovid) {out << theCovid << std::endl;});

std::accumulate() used for calculating the totalCases and totalDeaths. It seems fairly straightforward choice for the calculation of accumulated variables given the limitations of the workshop. Another fairly reasonable choice could have been to expand the use of earlier suggested the std::for_each(m_covid.begin(), m_covid.end(), [&](const Covid& theCovid) {out << theCovid << std::endl; totalCases+=theCovid. m_numOfCases; totalDeaths+= theCovid. m_deaths;});
std::sort() used for the sort functionality. Again, it seems fairly straightforward choice for the sorting. Perhaps there are more options for the use in the same functionality, although I haven’t been able to locate it.
std::transform() used it for the cleanList functionality. This algorithm allows us to transform the instances of the collection. I have embedded the transformation selection criteria and the transformation operation itself in the lambda expression. Perhaps I could have used the std::replace() std::replace_if() algorithms. But I have chosen to use std::transform() since we already had this algorithm provided by faculty that required just minor modifications to achieve the desired result. I think if spend some time practicing algorithms I will be able to come up with std::replace() and std::replace_if() suitable for this workshop.
std::any_of() used for inCollection functionality. Seems to be the best suited algorithm for the desired result. There are definitely more algorithms that can be used for this functionality, although their use seems to be slightly more complicated than the chosen one.
std::copy_if() used for getListForCountry and getListForVariant functionalities. It seems to be the best suited algorithm for the desired result. There are definitely more algorithms that can be used for this functionality, although their use seems to be slightly more complicated than the chosen one. I have attempted to use different algorithm for the getListForVariant functionality, but unfortunately have run out of time before I was able to complete it. I have attempted to use td::for_each(m_covid.begin(), m_covid.end(), [=] (const Covid& theCovid) {if (theCovid.m_variant == ariant) listVariant.push_back(theCovid); }); Unfortunately I was not able to figure out why my listVariant.push_back(theCovid) doesn’t work. I will definitely spend more time working on it. 

The main advantage of using STL functions is that the logic of is already written for us. In some cases, it is quite complicated multi-step operations, in other cases it is less complicated. Non the less, the use of STL functions saves us the redundancy, time, and lines of code. The use of STL functions allows for more reusable, solid and robust code.
In my opinion the best option would be instead of user typing field make the user select a field. Specifically, I would display the choices and the affiliated numerical value. Then ask for user to input the numerical value of the field. For example: country-1, city-2, variant-3 etc. So that it eliminates the possibility of misspelling the name of the field. The user input will need to be validated, to make sure it is within acceptable numerical range. Then the sorting will be done based on the numerical value entered by the user. For example: if (userInput == 1) {sort based on country;} else if (userInput==2) {sort based on city;} … else{throw “Invalid User Input”}; It will require the sorting functionality to be enclosed within try{}catch{} block. This will allow to eliminate spelling errors and detect invalid selection by the compiler.
I really have enjoyed the topic of STL algorithms and containers and looking forward to implementing it further in the course. Unfortunately, as with many other topics in the course the only thing that stopping me from practicing it at the moment is the absence of additional time. 
